From f0d987704704751b6f52a27e5de28fe699113323 Mon Sep 17 00:00:00 2001
From: Roee Hay
Date: Sun, 27 Nov 2016 15:30:42 +0200
Subject: [PATCH] Add a sysfs interface to bootloader mode. Remove fw version checking

---
 drivers/i2c/chips/CwMcuSensor.c | 227 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 227 insertions(+)
 mode change 100644 => 100755 drivers/i2c/chips/CwMcuSensor.c

diff --git a/drivers/i2c/chips/CwMcuSensor.c b/drivers/i2c/chips/CwMcuSensor.c
old mode 100644
new mode 100644
index 8f27b9a..19df6cd
--- a/drivers/i2c/chips/CwMcuSensor.c
+++ b/drivers/i2c/chips/CwMcuSensor.c
@@ -108,6 +108,28 @@ module_param(DEBUG_FLAG_GSENSOR, int, 0600);
 
 #endif
 
+#define BOOTLOADER_FLAG_RESET_TO_BOOTLOADER (1)
+#define BOOTLOADER_FLAG_RESET_TO_USERAPP (2)
+#define BOOTLOADER_FLAG_DONT_CHANGE_ADDR_TO_USERAPP (4)
+#define BOOTLOADER_FLAG_DONT_CHANGE_ADDR_TO_BOOTLOADER (8)
+
+#define BOOTLOADER_CMD_GET (0x00)
+#define BOOTLOADER_CMD_GETVERSION (0x01)
+#define BOOTLOADER_CMD_GETID (0x02)
+#define BOOTLOADER_CMD_READMEMORY (0x11)
+#define BOOTLOADER_CMD_GO (0x21)
+#define BOOTLOADER_CMD_ERASE (0x44)
+
+#define BOOTLOADER_CHECKSUM(n) (u8)(((u8 *)&n)[0] ^ ((u8 *)&n)[1] ^ ((u8 *)&n)[2] ^ ((u8 *)&n)[3])
+
+#define I2C_USERAPP_ADDR (0x72)
+#define I2C_BOOTLOADER_ADDR (0x39)
+#define I2C_ACK (0x79)
+#define I2C_NACK (0x1f)
+
+static ssize_t bootloader(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count);
 
 static int DEBUG_DISABLE;
 module_param(DEBUG_DISABLE, int, 0660);
@@ -1583,6 +1605,7 @@ static void update_firmware(const struct firmware *fw, void *context)
 	D("%s: firmware size = %lu\n", __func__, fw->size);
 
 	ret = check_fw_version(mcu_data, fw);
+    ret = 0;
 	if (ret == 1) { /* Perform firmware update */
 
 		mutex_lock(&mcu_data->activated_i2c_lock);
@@ -3921,6 +3944,7 @@ static struct device_attribute attributes[] = {
 	__ATTR(hall_sensor, 0440, get_hall_sensor, NULL),
 	__ATTR(led_en, 0220, NULL, led_enable),
 	__ATTR(facedown_enabled, 0660, facedown_show, facedown_set),
+    __ATTR(bootloader, 0220, NULL, bootloader),
 };
 
 
@@ -4380,6 +4404,209 @@ static int CWMCU_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 
+/*
+
+Usage examples: 
+
+
+GET:        echo 3 0  > /sys/class/htc_sensorhub/sensor_hub/bootloader
+READMEMORY: echo 3 0x11 0x08000000 0xff > /sys/class/htc_sensorhub/sensor_hub/bootloader
+
+
+*/
+static ssize_t bootloader(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct cwmcu_data *mcu_data = dev_get_drvdata(dev);
+    u32 chip = -1;
+	u32 cmd = -1;
+    u32 arg1 = -1;
+    u32 arg2 = -1;
+    u8 *b_arg1 = (u8 *)&arg1;
+    u8 *b_arg2 = (u8 *)&arg2;
+    
+    int n = 0;
+	int rc = 0;
+    int i = 0;
+	u8 i2c_data[255] = {0};
+
+	n = sscanf(buf, "%x %x %x %x", &chip, &cmd, &arg1, &arg2);
+	if (n < 2) {
+		E("%s: sscanf missing required args n = %d\n", __func__, n);
+		return -1;
+	}
+
+    mutex_lock(&mcu_data->activated_i2c_lock);
+    i2c_lock_adapter(mcu_data->client->adapter);
+
+    if (chip & BOOTLOADER_FLAG_RESET_TO_BOOTLOADER)
+    {
+        gpio_direction_output(mcu_data->gpio_chip_mode, 1);
+        mdelay(10);
+        gpio_direction_output(mcu_data->gpio_reset, 0);
+        mdelay(10);
+        gpio_direction_output(mcu_data->gpio_reset, 1);
+        mdelay(41);
+        D("BOOTLOADER: booted to bootloader\n");
+    }
+    
+    if (!(chip & BOOTLOADER_FLAG_DONT_CHANGE_ADDR_TO_BOOTLOADER))
+    {
+        D("BOOTLOADER: changed I2C target addr to bootloader\n");
+        mcu_data->client->addr = I2C_BOOTLOADER_ADDR;
+    }
+    
+    i2c_data[0] = cmd;
+    i2c_data[1] = ~cmd;
+
+    rc = i2c_tx_bytes_locked(mcu_data, i2c_data, 2);
+    rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+    I("BOOTLOADER CMD_ACK=%x\n", i2c_data[0]);
+    if (I2C_NACK == i2c_data[0])
+    {
+        E("BOOTLOADER ERROR: did not receive ACK\n");
+        goto cleanup;
+    }
+
+    switch (cmd)
+    {
+        case BOOTLOADER_CMD_GET:
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 13);
+
+            for (i = 0; i < 13 ; i++)
+            {
+                I("BOOTLOADER GET[%d]=%x\n", i, i2c_data[i]);
+            }
+
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            I("BOOTLOADER GET[ack]=%x\n", i2c_data[0]);
+            break;
+            
+        case BOOTLOADER_CMD_GETVERSION:
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            I("BOOTLOADER GETVERSION[%d]=%x\n", 0, i2c_data[0]);
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            I("BOOTLOADER GETVERSION[ack]=%x\n", i2c_data[0]);
+            break;
+
+        case BOOTLOADER_CMD_GETID:
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 3);
+            I("BOOTLOADER GETID[%d]=%x\n", 0, i2c_data[0]);
+            I("BOOTLOADER GETID[%d]=%x\n", 1, i2c_data[1]);
+            I("BOOTLOADER GETID[%d]=%x\n", 2, i2c_data[2]);
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            I("BOOTLOADER GETID[ack]=%x\n", i2c_data[0]);
+            break;
+        case BOOTLOADER_CMD_READMEMORY:
+            if (n < 4)
+            {
+                E("BOOTLOADER ERROR: missing args (n=%d)\n", n);
+                goto cleanup;
+            }
+           
+            i2c_data[0] = b_arg1[3];
+            i2c_data[1] = b_arg1[2];
+            i2c_data[2] = b_arg1[1];
+            i2c_data[3] = b_arg1[0];
+            i2c_data[4] = BOOTLOADER_CHECKSUM(arg1);
+            
+            rc = i2c_tx_bytes_locked(mcu_data, i2c_data, 5);
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            
+            I("BOOTLOADER READMEMORY[ack0]=%x\n", i2c_data[0]);
+            
+            if (I2C_NACK == i2c_data[0])
+            {
+                E("BOOTLAODER ERROR: did not receive ACK\n");
+                goto cleanup;
+            }
+            
+            
+            i2c_data[0] = b_arg2[0] - 1;
+            i2c_data[1] = ~i2c_data[0];
+            rc = i2c_tx_bytes_locked(mcu_data, i2c_data, 2);
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            I("BOOTLOADER READMEMORY[ack1]=%x\n", i2c_data[0]);
+            
+            if (I2C_NACK == i2c_data[0])
+            {
+                E("BOOTLOADER ERROR: did not receive ACK\n");
+                goto cleanup;
+            }
+            
+            
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, b_arg2[0]);
+            for (i = 0; i < b_arg2[0]; i++)
+            {
+                I("BOOTLOADER READMEMORY: 0x%08x = %02x\n", arg1 + i, i2c_data[i]);
+            }
+            break;
+            
+        case BOOTLOADER_CMD_GO:
+            if (n < 3)
+            {
+                E("BOOTLOADER ERROR: missing args (n=%d)\n", n);
+                goto cleanup;
+            }
+           
+            i2c_data[0] = b_arg1[3];
+            i2c_data[1] = b_arg1[2];
+            i2c_data[2] = b_arg1[1];
+            i2c_data[3] = b_arg1[0];
+            i2c_data[4] = BOOTLOADER_CHECKSUM(arg1);
+            
+            rc = i2c_tx_bytes_locked(mcu_data, i2c_data, 5);
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            
+            I("BOOTLOADER GO[ack0]=%x\n", i2c_data[0]);
+            
+            if (I2C_NACK == i2c_data[0])
+            {
+                E("BOOTLAODER ERROR: did not receive ACK\n");
+                goto cleanup;
+            }
+            break;
+        case BOOTLOADER_CMD_ERASE:
+           
+            i2c_data[0] = 0xFF;
+            i2c_data[1] = 0xFF;
+            i2c_data[2] = 0x00;
+            
+            rc = i2c_tx_bytes_locked(mcu_data, i2c_data, 3);
+            rc = i2c_rx_bytes_locked(mcu_data, i2c_data, 1);
+            
+            I("BOOTLOADER ERASE[ack0]=%x\n", i2c_data[0]);
+            break;
+    }
+
+cleanup:
+    
+    if (chip & BOOTLOADER_FLAG_RESET_TO_USERAPP)
+    {
+        gpio_direction_output(mcu_data->gpio_chip_mode, 0);
+        mdelay(10);
+        gpio_direction_output(mcu_data->gpio_reset, 0);
+        mdelay(10);
+        gpio_direction_output(mcu_data->gpio_reset, 1);
+        mdelay(41);
+        D("BOOTLOADER: booted to userapp\n");
+    }
+    
+    if (!(chip & BOOTLOADER_FLAG_DONT_CHANGE_ADDR_TO_USERAPP))
+    {
+        D("BOOTLOADER: changed I2C target addr to userapp\n");
+        mcu_data->client->addr = I2C_USERAPP_ADDR;    
+    }
+    
+
+    mutex_unlock(&mcu_data->activated_i2c_lock);
+    i2c_unlock_adapter(mcu_data->client->adapter);
+
+	return count;
+}
+
+
 static const struct dev_pm_ops cwmcu_pm_ops = {
 	.suspend = cwmcu_suspend,
 	.resume = cwmcu_resume
-- 
1.9.1

